---
title:  微服务落地实践
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2020-01-10 23:33:00 +0800
categories: [系统设计, 领域驱动设计 DDD]
tags:  [DDD]
math: true
mermaid: true
---

### 如何发挥微服务的优势

微服务也不是银弹，它有很多的“坑”。我们将一个庞大的业务系统拆分为一个个简单的微服务时，就是希望通过合理的微服务设计，尽量让每次的需求变更都交给某个小团队独立完成，让需求变更落到某个微服务上进行变更。唯有这样，每次变更只需独立地修改这个微服务，独立打包、独立升级，新需求就实现啦，才能发挥微服务的优势。

![This is a image](https://maxpixelton.github.io/images/assert/ddd/1001.png)

然而，过去很多系统都是这样设计的（如上图所示），多个模块都需要读取商品信息表，因此都通过 JDBC 直接读取。现在要转型微服务了，起初采用**数据共享**的微服务设计，就是数据库不变，然后简单粗暴地直接按照功能模块进行微服务拆分。这时，多个微服务都需要读取商品信息表，都通过 SQL 直接访问。这样的设计，一旦商品信息表发生变更，那么多个微服务都需要变更。这样的设计就使得微服务的**变更与发布变得复杂**，微服务的**优势无法发挥**。

![This is a image](https://maxpixelton.github.io/images/assert/ddd/1002.png)

通过 DDD 的指导，希望做“小而专”的微服务设计。按照这样的思路设计微服务，对商品信息表的读写只有“商品维护”微服务。当其他微服务需要读写商品信息时，就不能直接读取商品信息表，而是通过 API 接口去调用“商品维护”微服务。这样，日后因商品信息变更而修改的代码就只限于“商品维护”微服务。只要“商品维护”微服务对外的 API 接口不变，这个变更则与其他微服务无关。只有这样的设计，才能真正发挥微服务的优势。

为了规范“小而专”的微服务设计，在微服务转型之初，先按照 DDD 对数据库表按照用户权限进行划分。每个微服务只能通过自己的账号访问自己的表。当需要访问其他的表时，只能通过接口访问相应的微服务。这样的划分，就为日后真正的数据库拆分做好了准备，微服务转型将更加平稳。

### 怎样提供微服务接口

微服务的设计彼此之间不是孤立的，它们需要相互调用接口实现高内聚。然而，当一个微服务团队向另一个微服务团队提出接口调用需求时，另一个微服务团队该如何设计呢？

首先第一个问题，当多个团队都在向你提出 API 接口时，**怎么提供接口**。如果每个团队给你提需求，就必须要做一个新接口，那么微服务将变得非常不稳定。因此，当多个团队提需求时，必须要对这些接口进行规划，通过复用用尽可能少的接口满足他们的需求；当有新的接口提出时，要尽量通过现有接口解决问题。这样做，能用更低的维护成本，更好地维护自己的微服务。

接着，当调用方需要接口变更时怎么办？变更现有接口应当尽可能**向前兼容**，即接口的名称与参数都不变，只是在内部增加新的功能。这样做是为了不影响其他微服务的调用。如果确实需要更改现有的接口怎么办？**宁愿增加一个新的接口也最好不要去变更原有的接口**。

此外，调用双方传递的值对象需要完全一致吗？当然不用。当被调方因为某些变更对值对象增加了字段，而这些字段调用方不使用时，那么调用方不需要跟着变更值对象。因为微服务间的调用是采用RESTful 接口，以 JSON 的形成传递数据，是一种**松耦合的调用**。因此调用双方的值对象可以不一致，从而降低了需求变更的微服务更新范围。

最后，调用方如何调用接口呢？这里分为**同步调用**与**异步调用**。

具体设计实现上，就是在“用户接单”微服务的本地，增加一个“用户注册 Service”的 feign 接口。这样，“用户接单 Service”就像本地调用一样调用“用户注册 Service”，再通过这个 feign 接口实现远程调用。这样的设计叫作“**防腐层**”的设计。如下图所示：

![This is a image](https://maxpixelton.github.io/images/assert/ddd/1003.png)

譬如，想象这样一个场景。过去，“用户注册 Service”是在“用户下单”微服务中的。后来，随着微服务设计的不断深入，需要将“用户注册 Service”拆分到另外一个微服务中。这时，“用户下单Service”与“取消订单 Service”，以及其他对“用户注册 Service”的调用都会报错，都需要修改，维护成本就很高。这时，在微服务的本地放一个“用户注册 Service”的 feign 接口，那么其他的 Service 都不需要修改了，维护成本将得以降低。这就是“防腐层”的作用，即**接口变更时降低维护成本**。

### 去中心化的数据管理

按照 DDD 的设计，已经将数据库按照微服务划分为用户库、下单库、接单库、派送库与饭店库。这时候，如何来落地这些数据库的设计呢？微服务系统最大的设计难题就是要**面对互联网的高并发与大数据**。因此，**可以按照**“**去中心化数据管理**”**的思想**，**根据数据量与用户访问特点**，**选用不同的数据存储方案存储数据**：

- 微服务“用户注册”与“饭店管理”分别对应的用户库与饭店库，它们的共同特点是**数据量小但频繁读取**，可以选用小型的 MySQL 数据库并在前面架设 Redis 来提高查询性能；
- 微服务“用户下单”“饭店接单”“骑士派送”分别对应的下单库、接单库、派送库，其特点是**数据量大并且高并发写**，选用一个数据库显然扛不住这样的压力，因此可以选用了 TiDB 这样的 NewSQL 数据库进行分布式存储，将数据压力分散到多个数据节点中，从而解决 I/O 瓶颈；
- 微服务“经营分析”与“订单查询”这样的查询分析业务，则选用 NoSQL 数据库或大数据平台，通过读写分离将生产库上的数据同步过来进行分布式存储，然后经过一系列的预处理，就能应对海量历史数据的决策分析与秒级查询。

**基于以上这些设计**，**就能完美地应对互联网应用的高并发与大数据**，**有效提高系统性能**。设计如下图所示：

![This is a image](https://maxpixelton.github.io/images/assert/ddd/1004.png)

### 数据关联查询的难题

此外，各个微服务在业务进行过程需要进行的各种查询，由于数据库的拆分，就不能像以前那样进行 join 操作了，而是通过接口调用的方式进行数据补填。比如“用户下单”“饭店接单”“骑士派送”等微服务，由于数据库的拆分，它们已经没有访问用户表与饭店表的权限，就不能像以往那样进行 join 操作了。这时，需要重构查询的过程。如下图所示：

![This is a image](https://maxpixelton.github.io/images/assert/ddd/1005.png)

查询的过程分为 2 个步骤。

1. 查询订单数据，但不执行 join 操作。这样的查询结果可能有 1 万条，但通过翻页，返回给微服务的只是那一页的 20 条数据。
2. 再通过调用“用户注册”与“饭店管理”微服务的相关接口，实现对用户与饭店数据的补填。

**这种方式**，**既解决了跨库关联查询的问题**，**又提高了海量数据下的查询效率**。注意，传统的数据库设计之所以在数据量越来越大时，查询速度越来越慢，就是因为**存在 join 操作**。因而，在面对海量数据的查询时，干掉 join 操作，改为分页后的数据补填，就能有效地提高查询性能。

然而，在查询订单时，如果要通过用户姓名、联系电话进行过滤，然后再查询时，又该如何设计呢？**这里千万不能先过滤用户数据**，**再去查询订单**，**这是一个非常糟糕的设计**。我们过去的数据库设计采用的都是**3NF（第 3 范式）**，它能够帮助我们**减少数据冗余**，然而却带来了**频繁的 join 操作**，**降低了查询性能**。因此，为了提升海量数据的查询性能，适当增加冗余，即在订单表中增加用户姓名、联系电话等字段。这样，在查询时直接过滤订单表就好了，查询性能就得到了提高。

最后，当系统要在某些查询模块进行订单查询时，可能对各个字段都需要进行过滤查询。**这时就不再采用数据补填的方式**，**而是利用 NoSQL 的特性**，**采用“宽表”的设计**。按照这种设计思路，当系统通过读写分离从生产库批量导入查询库时，提前进行 join 操作，然后将 join 以后的数据，直接写入查询库的一个表中。由于这个表比一般的表字段更多，因此被称为“宽表”。

由于 NoSQL 独有的特性，为空的字段是不占用空间的，因此字段再多都不影响查询性能。这样，在日后的查询时，就不再需要 join 操作，而是直接在这个单表中进行各种过滤、各种查询，从而在海量历史数据中实现秒级查询。因此，“订单查询”微服务在数据库设计时，就可以通过NoSQL 数据库建立宽表，从而实现高效的数据查询。
