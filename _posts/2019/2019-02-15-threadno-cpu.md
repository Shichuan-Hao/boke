---
title: 合适的线程数量以及 CPU 核心数与线程数的关系
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2019-02-15 23:33:00 +0800
categories: [Java, 并发]
tags: [thread]
math: true
mermaid: true
---

调整线程池中的线程数量的最主要的目的是：**为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。**

在实际工作中，需要根据任务类型的不同选择对应的策略。

## CPU 密集任务 & IO 密集任务
CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。


## CPU 密集型任务

CPU 密集型任务，比如**加密**、**解密**、**压缩**、**计算**等一系列需要大量耗费 CPU 资源的任务。

对于这样的任务最佳的线程数为 CPU 核心数的 `1~2` 倍，如果设置过多的线程数，并不会起到很好的效果。

假设设置的线程数量是 CPU 核心数的 2 倍以上，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，又因为设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。

> 上下文切换：
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。
Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。
{: .prompt-info }

针对这种情况，最好同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。


## 耗时 IO 型任务

耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。

对于这种任务，最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的。

如果设置过少的线程数，就可能导致 CPU 资源的浪费。

如果设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。
 
## 计算方法

**简单并且适用面比较广的公式：**
= CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

**《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：**
$$
线程数 = CPU 核心数 * （1 + \frac{WT}{ST}）
$$
其中，WT 为线程等待时间，ST 是线程计算时间，WT 的计算方法为：$$WT = 线程运行总时间 - ST$$

> 平均工作时间和平均等待时间，可以在上线后，通过写代码等办法统计到各部分语句的运行时长。
{: .prompt-tip }

> 可以使用 JDK 自带的工具 VisualVM 来查看线程等待时间和线程工作时间
{: .prompt-tip }

通过这个公式，可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是 CPU 密集型任务，线程数就随之减少。

> 合适的线程数量，corePoolSize 和 maxPoolSize 都涉及到，不过主要指 corePoolSize。
{: .prompt-tip }

 
太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行**压测**，**监控 JVM 的线程情况**以及 **CPU 的负载情况**，根据实际情况衡量应该创建的线程数，合理并充分利用资源。


## 结论

综上所述可以得出一个结论：
- 线程的平均工作时间所占比例越高，需要越少的线程；
- 线程的平均等待时间所占比例越高，需要越多的线程；
- 针对不同的程序，进行对应的实际测试就可以得到最合适的选择。






