---
title: 问题整理（1）
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2019-06-02 23:33:35 +0800
categories: [计算机基础, 操作系统]
tags: [图灵机, 图灵机的构造, 图灵机执行程序, 冯诺依曼模型]
math: true
mermaid: true
---

### 1 如何计算一个人程序写得好不好 ?

这个问题可以这样思考，如果把问题降级变成：“可不可以计算一个人写的程序会不会停机？”

这个问题如同停机问题，无法计算，因此这是一个不可计算的问题。但是通过设立规则，比如检查缩进、检查函数的复用情况、检查类的命名情况，给写程序的人更好的建议。

另外，也可以通过 AI 技术，让机器在“程序写得好不好”这个问题的判定能力上，达到人类的水平，通过图灵测试。

综上，从绝对的对错角度去看，这是一个不可计算问题，因为它没有办法被完全解决；但是从图灵测试层面来看，虽然目前无法解决这个问题，但是有理由相信，在未来，计算机对这个问题的解决方案，是可以超过人类的。



### 2 可不可以构造一段程序证明停机问题无解 ？

**先从问题的抽象入手：**

- 判断一段程序是否会停机的方法可以抽象成一个函数；
- 一段程序，也可以抽象成一个函数。

因此，问题可以转换为：存不存在一个通用函数判断另一个函数是否会停止 ？

构造冲突，假设存在一个函数 willStop，它只有一个参数 func，willStop 可以判断任意函数 func 是否会停止。如果会停止，返回 true；如果不会停止，返回 false.

willStop 具体如何实现无法给出，假设伪代码如下：

```c++
func willStop(func) {
    // ……
}
```

构造一组冲突，构造一个叫做 wrapperWillStop 函数，它调用 willStop 构造冲突。

```c++
fun wrappedWillStop() {
    if(willStop(wrapperdWillStop)) {
        while(true) {}
    } else {
        return
    }
}
wrappedWillStop()
```

wrapped 版本构造冲突方法如下：调用 willStop 并把自己传进去。如果 willStop认为 wrapped会停止，那么就执行一个死循环。 如果 willStop 认为wrapped不会停止，就直接返回。

通过上述的方法，可知 willStop这样的函数肯定是无法被实现的；也就是停机问题无解。





### 3 64 位和 32 位比较有哪些优势了吗 ？

如果说的是 64 位宽 CPU，那么有 2 个优势：

1. 优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显；
2. 优势 2：64 位 CPU 可以寻址更大的内存空间：
   - 如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数；
   - 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。



### 4 CPU 中有没有求对数的指令？如果没有那么程序如何去计算？

CPU 中求一个数字的 2 倍，可以通过左移指令。比如 10 代表数字 2，左移 1 位变成 100 就代表数字 4。CPU 提供了乘法指令，所以如果求一个数字的幂，比如 3^3^，可以拿 $3 * 3$ 再乘以 3，需要计算 2 次;

但是如果求 3^100^ 次方，就不会去计算 100 次。比如可以先计算出 3^25^，然后再求 (3^50^)^2^，就是 3^100^。所以这样就节省了 1 倍的运算;

由此可见，CPU 没有提供很复杂的指令，但是这里有很多算法可以降低我们的时间开销；

至于求对数，**求对数也是没有指令的。**因为对数是指数的逆运算，当然可以利用乘法运算一点点尝试。比如计算 $log_210 $，可以先尝试 3^2^，再尝试 3.1^2 等等，一直找到以 2 为底 10 的对数。这其实是个近似算法；

另外，在这个问题上聪明的数学家提出了很多近似算法，提升了计算效率（具体这里比较超纲，面试通常只考到有没有求对数的指令，感兴趣可以研究泰勒级数、牛顿迭代法等）。

比如下面这个泰勒级数可以用来求以 e 为底的对数，可以进行相似运算：
$$
ln(1+x) = \sum_{n=1}^\infty \frac{(-1)^{n+1}}{n}x^2 = x - \frac{x^2}{2} + \frac{x^3}{3} - ··· + \frac{(-1)^{n+1}}{n}x^2 + ···    \forall\in(-1, 1]
$$

### 5 一位的 CPU 能操作多大的内存空间？

**无限大**。

比如说，地址总线 40 位，说明 CPU 上有 40 个引脚接了地址总线。CPU 只有 1 位，因此操作这 40 个引脚可以分成 40 步。每次设置 1 根引脚的电平是 0 还是 1。所以本身 CPU 多少位和能操作多少位地址总线，没有本质联系。但是如果需要分步操作，效率会低，需要多次操作，不如一次完成来得划算。 因此我们今天的设计通常不拿 32 位 CPU 操作 40 位地址总线，而是用 64 位 CPU 操作。



## 6 将一个递归函数转成非递归函数的通用方法

- 需要到一个栈（其实用数组就可以）；
- 还需要一个栈指针，支持寄存器的编程语言能够直接用寄存器，而不支持直接用寄存器的编程语言，比如 Java，可以用一个变量；
- 然后可以实现压栈、出栈的操作，并按照上面学习的函数调用方法操作栈。

### 7 假设使用的程序语言不支持递归程序，如果要求用栈来模拟下面这个斐波那契求第 n 项的程序，应该如何转换成等价的基于栈的非递归实现

```c++
int fib(int n) {
    if( n == 1 || n == 2 ) {
        return n;
    } else {
        return fib(n-1) + fib(n-2)
    }
}
```

这道题目等同于递归的函数如何非递归表达？改写斐波那契数列第 N 项目。下面是伪代码：

```c++
fib(n) {
    stack = new Stack();
    
    // 构造Stack
    // stack中每一项是一个Record
    // Record第一项是数据（参数或者返回值）
    // Record第二项是递归方向(down=1代表向下，up=2代表向上)
    stack.push((n, down));
    
    // stack 中只有一项的时候递归停止
    while(stack.size() > 1) {
        (n, phase) = stack.pop();
        
        if(phase == down) {
            if(n == 1 || n == 2) {
                statck.push(1, -))
                continue
            }
            stack.push((n-1, down))
            stack.push((n-1, up))
        } else {
            last1 = stack.pop()
            last2 = stack.pop()
            stack.push((last1[0] + last2[0], up))
        }
    }
    return stack.pop()[0];
}
```



### 8 SSD、内存和 L1 Cache 相比速度差多少倍？

因为内存比 SSD 快 10~1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000~100000 倍。所以 SSD 的潜力很大，好的 SSD 已经接近内存了，只不过造价还略高。

这个问题告诉我们，不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造缓存体系。



### 9 假设有一个二维数组，总共有 1M 个条目，如果要遍历这个二维数组，应该逐行遍历还是逐列遍历？

二维数组本质还是 1 维数组。只不过进行了脚标运算。比如说一个 N 行 M 列的数组，第 y 行第 x 列的坐标是： $x + y * M$。因此当行坐标增加时，内存空间是跳跃的。列坐标增加时，内存空间是连续的。

![这是一张图片](https://images.happymaya.cn/assert/os/thinking-0501.png)

当 CPU 遍历二维数组的时候，会先从 CPU 缓存中取数据。

关键因素在于现在的 CPU 设计不是每次读取一个内存地址，而是读取每次读取相邻的多个内存地址（内存速度 200～300 CPU 周期，预读提升效率）。所以这相当于机器和人的约定，如果程序员不按照这个约定，就无法利用预读的优势。

另一方面当读取内存地址跳跃较大的时候，会触发内存的页面置换。
