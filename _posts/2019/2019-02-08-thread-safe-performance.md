---
title: 并发带来性能问题
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2019-02-08 23:33:00 +0800
categories: [Java, 并发]
tags: [thread]
math: true
mermaid: true
---

## 什么是性能问题   

对于多线程而言，它不仅可能会带来线程安全问题，还有可能会带来性能问题。

虽然使用多线程的最大目的是为了**提高性能吗**，通过让多个线程同时工作，从而加快程序运行速度，但是多线程（单线程程序是独立工作的，不需要与其他线程进行交互）之间则需要调度以及合作，调度与合作就会带来性能开销从而产生性能问题。

性能问题有许多的表现形式，比如：**服务器的响应慢**、**吞吐量低**、**内存占用过多**。

我们设计优秀的系统架构、购置更多的 CDN 服务器、购买更大的带宽等都是为了提高性能，提高用户体验，虽然运行速度慢不会带来严重的后果，通常只需要多等几秒就可以，但这会严重影响用户的体验。

有研究表明，**页面每多响应 1 秒，就会流失至少 7% 的用户，而超过 8 秒无法返回结果的话，几乎所有用户都不会选择继续等待**。

引入多线程的一大重要原因就是想提高程序性能，所以不能本末倒置，不能因为引入了多线程反而程序运行得更慢了，所以必须要解决多线程带来的性能问题。



## 多线程会带来性能问题的场景

主要有两个场景多线程编程会带来性能问题：
1. 线程调度；
2. 线程协作。

### 调度开销

**上下文切换**

在实际开发中，线程数往往是大于 CPU 核心数的，比如 CPU 核心数可能是 8 核、16 核，等等。

但线程数可能达到成百上千个。这种情况下，操作系统就会按照一定的调度算法，给每个线程分配时间片，让每个线程都有机会得到运行。

而在进行调度时就会引起上下文切换，上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程，以此类推，反复执行。

但上下文切换带来的开销是比较大的，假设我们的任务内容非常短，比如只进行简单的计算，那么就有可能发生**上下文切换带来的性能开销比执行线程本身内容带来的开销还要大的情况**。

> 上下文切换：<br/>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。<br/>
上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<br/>
Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。
{: .prompt-info }

**缓存（CPU 高速缓存）失效**

不仅上下文切换会带来性能问题，缓存失效也有可能带来性能问题。

由于程序有很大概率会再次访问刚才访问过的数据，所以为了加速整个程序的运行，会使用缓存，这样在使用相同数据时就可以很快地获取数据。

一旦进行线程调度，切换到其他线程，CPU 就会执行不同的代码，原有的缓存就很可能失效，需要重新缓存新数据，这也会造成一定的开销，所以线程调度器为了避免频繁地发生上下文切换，通常会给被调度到的线程设置最小的执行时间，也就是只有执行完这段时间之后，才可能进行下一次的调度，由此减少上下文切换的次数。

那么什么情况会导致密集的上下文切换呢？如果程序频繁地竞争锁，或者由于 IO 读写等原因导致频繁阻塞，那么这个程序就可能需要更多的上下文切换，这也就导致了更大的开销，我们应该尽量避免这种情况的发生。

### 协作开销  

除了线程调度之外，**线程协作**同样也有可能带来性能问题。

因为线程之间如果有共享数据，为避免数据错乱，保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化，也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主存 refresh 到其他线程的工作内存中等等。

这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了性能。
