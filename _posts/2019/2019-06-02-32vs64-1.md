---
title: 程序的执行 — 上
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2019-06-02 23:33:35 +0800
categories: [计算机基础, 操作系统]
tags: [图灵机, 图灵机的构造, 图灵机执行程序, 冯诺依曼模型]
math: true
mermaid: true
---


## 图灵机的构造

想要搞清楚程序是如何执行的，就要从图灵机说起。图灵机在计算机科学方面有两个巨大贡献：

1. 清楚定义计算机能力边界，即可计算理论；
2. 定义计算机的组成，程序又是如何执行的。

![这是一张图片](https://images.happymaya.cn/assert/os/0201.png)

如上图可以看出，图灵机的内部构造：

1. 一条无限长的纸带。纸带上是一个个紧挨着的格子，格子中可以写字符（把纸带看作内存，这些字符看作是内存中的数据或者程序）；
2. 有一个读写头。读写头可以读取或修改任意格子上字符；
3. 读写头上面的盒子里是一些精密的零件，包括存储、控制单元和运算单元。



### 图灵机执行程序

比如，要计算 `11 + 15` 的值，具体运算步骤如下：

1. 将`11`、`15`、`+` 分别写入纸带上 3 个格子（现在纸带上的字符串是`11`、`15`、 `+`)，然后将读写头先停在 `11` 对应格子上；

   ![这是一张图片](https://images.happymaya.cn/assert/os/0202.png)

2. 图灵机通过读写头将 `11` 读入存储设备中（存储设备也叫作图灵机的状态），图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点；

   ![这是一张图片](https://images.happymaya.cn/assert/os/0203.png)

   

3. 然后，读写头向右移动一格，用同样的方法将 `15` 读入存储设备中，此时存储设备中有两个连续的数字`11` 和 `15`；

   ![这是一张图片](https://images.happymaya.cn/assert/os/0204.png)

   

4. 接着，重复上面过程，会读到一个`+` 号，详细过程如下：

   - 读写头读到一个 `+` 号 ；

   - 将 `+` 号传输给控制单元；

   - 控制单元发现是一个 `+ `号，没有存入状态中。因为 `+` 号是预设控制符（指令），它的作用是加和目前状态。因此，控制单元识别出是控制符，并通知运算单元工作；

   - 运算单元从状态中读入 `11`、`15` 并进行计算，将结果 `26` 存储到状态；

   - 运算单元将结果回传给控制单元；

   - 控制单元将结果传输给读写头；

     ![这是一张图片](https://images.happymaya.cn/assert/os/0205.png)

   - 读写头向右移动，将结果 26 写入纸带。

   ![这是一张图片](https://images.happymaya.cn/assert/os/0206.png)

这样，通过图灵机计算出了 $11+15$ 的值。图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计如今的计算机是一样的。

**图灵通过数学证明了，两个方面的问题：**

1. 一个问题如果可以拆解成图灵机的可执行步骤，这个问题就是可计算的；
2. 图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。

## 冯诺依曼模型

![这是一张图片](https://images.happymaya.cn/assert/os/0207.png)

具体实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出。

报告遵循图灵机的设计，提出用电子元件构造计算机，约定用二进制进行计算和存储，并将计算机结构分为下面五个部分：

- 输入设备；
- 输出设备；
- 内存；
- 中央处理器（CPU）；
  - 控制单元和逻辑运算单元
  - 寄存器
  
- 总线。

这个模型被称为==**冯诺依曼模型**==。

### 内存

在冯诺依曼模型中，**程序和数据被存储在一个被称作==内存==的==线性排列存储区域==**：

- 存储的数据单位是一个二进制位，英文是 bit；
- 最小存储单位是字节，8 位，英文是 byte；
- 每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中字节数减 1。

通常说的内存都是随机存取器，即读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。

### CPU

冯诺依曼模型中 CPU 负责控制和计算。

为方便计算较大数值，CPU 每次可以计算多个字节的数据：

- 如果 CPU 每次可以计算 4 个 byte，称作 32 位 CPU；
- 如果 CPU 每次可以计算 8 个 byte，称作 64 位 CPU。

这里的 32 和 64，称作 CPU 的==**位宽**==。

这样设计原因：一个 byte 最大表示范围是 0~255。比如要计算 20000*50，就超出了byte 最大表示范围。因此，CPU 需要支持多个 byte 一起计算。

当然，CPU 位数越大，可以计算数值就越大。但是在现实生活中不一定需要计算这么大数值。比如说 32 位 CPU 能计算的最大整数是 4,294,967,295，已经非常大了。

#### 控制单元和逻辑运算单元

CPU 中有一个控制单元专门负责控制 CPU 工作；有一个逻辑运算单元专门负责计算。

#### 寄存器

CPU 要进行计算，比如最简单的两个数字相加，因为 CPU 离内存太远，所以需要一种相近的存储来储存将要被计算的数字，这种存储就是寄存器！

寄存器就在 CPU 里，距离控制单元和逻辑运算单元非常近，因此速度很快。

寄存器有三个部分：

- 通用寄存器。可供用户编程。比如用来存加和指令的两个参数；

- 特殊寄存器。具有特殊用途。比如程序指针，就是一个特殊寄存器。它存储 CPU 要执行下一条指令所在的内存地址。**注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。**

- 指令寄存器。指令被执行完成之前，都存储在这里，下一条要执行的指令，会从内存读入到这个寄存器。

### 总线

CPU 和内存以及其他设备之间，需要通信，因此用一种特殊设备进行控制，就是总线。

总线分成 3 种：

- 地址总线，用来指定 CPU 将要操作的内存地址；
- 数据总线，用来读写内存中数据；

- 控制总线，用来发送和接收关键信号，比如中断信号、设备复位、就绪等信号都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，也需要控制总线。

当 CPU 需要读写内存时，先通过地址总线来指定内存地址，再通过数据总线来传输数据。

### 输入、输出设备

输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。

如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，需要用到控制总线。



## 注意点

这个有两个需要注意的问题：

1. 线路位宽问题；
2. 64 位和 32 位的计算。



### 线路位宽问题

数据通过操作电压（低电压是 0，高电压是 1）在线路传递。

如果只有一条线路，每次只能传递 1 个信号，因此必须在 0，1 中选一个。比如：构造高高低低这样的信号，就是 1100，相当于传了一个数字 10 过去。这种传递是相当慢，因为需要传递 4 次。这种**一个 bit 一个 bit 发送的方式，叫作串行。**

如果希望每次多传一些数据，需要增加线路，就是需要**并行：**

- 如果有 1 条地址总线，每次只能表示 0-1 两种情况，可操作 2 个内存地址；
- 如果有 10 条地址总线，一次表示 2^10^ 种情况，可操作 1024 个内存地址；
- 如果操作 4G 的内存，需要 32 条线，因为 2^32^ 是 4G。

串行发送也不是不行，只是速度会很慢，每多增加一条线路速度就会翻倍。



### 64 位和 32 位的计算

CPU 的位宽会对计算造成的影响。一个具体场景：用 32 位宽的 CPU，加和两个 64 位的数字。

32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。

因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如加法竖式，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。

而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。

**千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。**

大部分应用不需要计算超过 32 位的数字，比如一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。

还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。



## 总结

- 图灵机
- 程序的执行
- 冯诺依曼模型
- 计算机的组成
- CPU 的工作原理