---
title: 异常处理的基本原则
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2018-03-02 14:33:00 +0800
categories: [Java, 异常]
tags:  [exception rules]
math: true
mermaid: true
---

首先抛出来议题，也就是异常处理的三个基本原则：

- 搞清楚可能会出现什么错误，即明确出异常的类型
- 搞清楚哪里可能会出错，即明确异常产生的范围
- 搞清楚这里为什么会出错，即明确异常的处理方式

### 明确出异常的类型

程序中可能抛出的异常无非两类：checked 和 unchecked，对于这两类异常，应该知道如何去处理它们。但是，该怎样知道程序中可能会出现什么错误呢？先来看第一个例子：

```java
public void fun() throws FileNotFoundException {
  ......
}
```

可以看到，fun 方法声明会抛出 FileNotFoundException，那么，如果方法调用了 fun，无疑这段程序就可能会出现 “文件找不到” 的错误。当然来说，这类问题比较简单，也是很明显的一类问题（但是，仍然是很有代表性）。再来看第二个例子：

```java
public Object fun() {
  // ......
  return obj;
}

Object obj = fun();
obj.x();
```

这段代码可能会出现一个 “隐式” 的错误，通过调用 `fun` 方法获取了 obj 对象，然后直接调用了 Object 的 x 方法。但是，有没有可能 obj 是 null 呢？有没有可能 `fun` 方法抛出运行时异常呢？当然，一切皆有可能！所以，对于上面的这段代码来说，可能会出现两类问题：

- `fun` 返回的 obj 为 null，调用 x 方法抛出空指针异常
- `fun` 内部执行逻辑出错，抛出空指针异常

到这里，应该明白了怎样去 “发现” 程序中可能出现的错误。当然，这里示例比较简单，不过，万变不离其宗，方法对了，实现只是众多可行实现的一种方式。所以，既然知道了当前的代码可能出现的错误（以及异常的类型），就有理由去规避这些问题了。

### 明确异常产生的范围

乍看起来，第二个原则与第一个原则很像，但是，它们有很大的区别。因为这里并不是说去确定具体的异常类型，而是 `try...catch` 代码块应该要 “包住” 哪些代码。我曾经见过一个小伙伴把一个方法中的所有代码都放在了 try 里面，我知道他这样做的意图，但是，这样做正确吗？或者说合适吗？来看第三个例子：

```java
public void fun(int num1, int num2, String fileName) {

    try {
        int sum = num1 + num2;
        File file = new File(fileName);
        OutputStream out = new FileOutputStream(file);
        out.write(sum);
        out.close();
    } catch(Exception ex) {
        ex.printStackTrace();
    }
}
```

可以看到，这个方法中执行的代码确实可能会抛出很多异常，例如：FileNotFoundException、NullPointerException 等等，所以，把代码用 `try...catch` 包裹起来是没有问题的。但是，真的需要把全部的代码都包裹起来吗？答案是没有必要，甚至是错误的。这段代码修改一下：

```java
public void fun(int num1, int num2, String fileName) {

    int sum = num1 + num2;
    File file = new File(fileName);

    try {
        OutputStream out = new FileOutputStream(file);
        out.write(sum);
        out.close();
    } catch(Exception ex) {
        ex.printStackTrace();
    }
}
```

我把前两句代码提到 try 的外面了，原因有两个：

- 两个 int 类型的数值求和，不可能会抛出异常，根本没有必要放到 try 中
- 虽然 `new File` 构造函数可能会抛出空指针，但是，这确是由参数 fileName 为 null 引起的，根本不是业务逻辑出错

由此可以得出结论：需要处理的异常是针对于业务逻辑的，非业务逻辑的问题应该是尽早暴露出来，让异常抛出来，而不是想着去兼容 “疏忽”。

### 明确异常的处理方式

这是一个非常有意思的原则，这个原则指的是：要不要处理程序中的异常。听到这个解释是不是一脸问号呢？我们已经预料到了程序中可能会出现异常，还考虑要不要去处理？首先，我们思考一个问题：如果程序中抛出异常，我们没有手动捕获，会出现什么问题？

- 当前的接口不可用，返回 Exception 给调用方
- 程序直接退出

所以，一旦出现没有捕获的异常，至少当前的接口肯定是不可用的（这里先不考虑对接口做降级处理）。但是，及时的抛出异常也会有很多好处，即在一些特定的场景下，抛出异常不做处理是有意义的：

- 防止问题扩散，例如对于 NPE 问题来说，如果不提早抛出异常的话，这个 null 可能会藏的比较深，等到出现 NPE 时就需要往回追溯代码了
- 参数传递错误，这很明显是调用方的问题，不应该由提供者去做兜底，你调用我的方法，就应该遵循我的规定
- 核心业务逻辑，我通常很反对尝试捕获核心业务逻辑中出现的错误，应该是让异常 “尽情的往外抛”，这样才能够及时的发现自己的失误，做到亡羊补牢

综上所述，你一定要搞清楚你的程序为什么会出错，并得出结论，要不要去处理这个异常，还是让它抛出来。刚开始，你可能会觉得这种做法有点奇怪，但是，慢慢的，你会发现及时的发现问题、解决问题是多么的重要！

## 自定义异常和标准异常之间的取舍

我们在业务系统中应该如何抉择呢？即究竟是应该自定义还是直接使用 Java 语言的标准异常呢？

### 使用标准异常的好处

Java 世界中的一本经典之作《Effective Java》中就单独有一节说到：尽量使用标准的异常。既然书中这么说了，就一定有它的原因、有它的好处。

### 更加易于学习和使用的 API

作为一个 Java 程序员，非常熟悉 “那些” 常见的异常。即使是不常出现的异常，也能够通常搜索引擎找到类似的问题。但是，如果定义了 BizException，且没有写清楚说明文档，这无疑在将来会成为维护者的噩梦。因为如果他不去读你的代码上下文，就根本不会知道你想表达的是什么。所以，大多数的程序员肯定希望你使用标准异常去表达错误。

同时，对于标准的异常来说，程序员几乎是没有学习成本的，更甚者，应该是看到这个错误，就大概能够知道什么原因会导致这样的错误。

### 提高程序的整体性能

异常也是 Java 类，所以，如果没有额外的自定义异常类，编译器就不需要做额外的编译工作。同时，JVM 也就不会加载这些类。那么，自然程序的性能会有所提高（当然，这种提高肯定是不明显的，大多数时候只能停留在理论层面）。

可以看到，这两条理由是非常合理的，也是重要的指导原则。总结下来一句话：**如果没有必要，即标准异常能够表达你的问题，使用标准异常肯定是更好的选择。**

### 何时考虑使用自定义异常

既然标准异常有那么多好处，自定义异常还有用武之地吗？当然，有两类场景支持使用自定义异常：

- 业务场景复杂，涉及的分系统或子系统很多，且各个子系统之间也有复杂的业务逻辑
- 框架或者工具库、SDK 等等

对于复杂业务场景（特别是微服务）的情况，自定义异常是很有必要的，可以根据自定义的异常及时的定位到是哪一部分（某一个子系统）出了问题。例如，对于电商服务来说，如果抛出了 “订单创建异常”，肯定会去查看订单子系统，而不可能会去查询仓储子系统。这就是对于复杂业务场景的巨大优势。

那么，为什么针对于框架（工具库、SDK）要自定义异常呢？首先，可以想想为什么 Spring、Android 这些框架会自定义异常呢？原因其实很简单：因为框架是提供多样的功能，为了能在出错时尽快知道可能是 “哪一块代码” 的问题，自定义异常并给出说明是最好的方案。对的，其实这与复杂业务场景自定义异常的思想是一致的。

总之，标准异常没有学习成本，且效率高，是最优先被选择的方案。但是，如果业务场景很复杂、编写一个框架（工具或 SDK），有必要考虑自定义一些异常。不过，对于写代码来说，唯一的要求只是语法正确，其他的还要看对业务的理解，对工程建模的把握。

## 该怎么处理异常

### 从源头减少异常

业务代码中往往伴随着异常，但是，它们却是独立的 “个体”，这一点一定要能够理解。业务代码中应该至少 90% 以上的代码在处理业务逻辑，而不是更多的考虑可能会出现什么异常或错误。我们看一个例子：

```java
public Object fun() {
  // ...
  return obj;
}

public void process() {

  try {
    Object obj = fun();
    obj.x();
  } catch(NullPointerException ex) {
    // ...
  }
}
```

很明显，process 中对 obj 的 `try...catch` 就是多余的，因为这并不属于业务逻辑，而是 fun 方法出错造成的问题。应该考虑让异常抛出来，并定位解决问题，而不是想办法规避这个错误。

### 忽略不必要的异常

有些时候，明知某一段代码可能会出现问题，所以，使用 `try...catch` 或者 `throws` 向上抛出等等方案。但是，很多时候，在 catch 里面仅仅打印一条日志，记录下这里的异常，然后继续执行后面的代码，这种就算作是忽略了当前的异常。那么，什么时候我们可以这样做呢？总结下来，如果有这样的几种情况，可以考虑这样做：

- for 循环中处理数据，允许有一定的容错率
- 存在网络连接、rpc 调用等等，允许失败之后的重试
- 不影响业务的整体逻辑，例如手机验证码发送失败
- …

### 通过异常链定位 root cause

异常经过转换之后再向上抛出，就很难追踪到原始错误，即 root cause。所以，需要在转换异常时 “带上” 原本的异常信息。所以，需要知道 Throwable 中的一个构造方法（也有其他的构造方法可用，但是，这个最常用）：

```java
public Throwable(String message, Throwable cause) {
    fillInStackTrace();
    detailMessage = message;
    this.cause = cause;
}
```

在转换异常再次抛出的时候，一定不要只记录异常的 message，要同时把 cause 返回给调用方，由此形成异常链条。

### 一些需要考虑的细节问题

除了上面需要注意/遵循的原则之外，还有一些需要考虑的细节。总结下来，有这样的几点：

- 仅捕获有必要的代码段，不要大段的使用 try
- 尽量不要捕获 Exception 这种通用异常，而是捕获更加具体的异常
- 在异常处理后要及时的清理、释放资源
- 尽早的让异常暴露出来，例如：尽早验证用户输入以在请求处理的早期捕获异常

不要担心代码中异常过多，也不要害怕处理不好异常；如果所有代码都正确，那么，其实对自身提升就很有限了；异常处理无非就是追踪异常栈，找到抛异常的那一句代码，联系上下文，确定原因并解决之。

### 关于异常的一切

对于 Java 语言来说，掌握异常是每一个程序员必备的技能，同时，也应该能够灵活的应用异常来给程序代码做出说明。

### Java 异常的历史和地位

在使用其他语言的话，检查异常（checked exception）是 Java 语言的一大不同点，其他语言只有 RuntimeException。这是为什么呢？在 90 年代中期，Sun 公司的 James Gosling 提出了一种新的语言。当时，C++ 编程要求每个返回的函数都要检查是否有错误。他认为必须找出更好的方法，并因此将 “异常” 的概念构建到 Java 语言中。

检查异常的目的是在本地标志，并强制开发人员处理可能的异常。已检查的异常必须在方法签名上声明或处理。这是为了增强软件的可靠性和弹性。人们希望从意外状况中 “恢复” —— 提供可预测的失败结果，例如尝试付款时发生的 InsufficientFundsException。关于实际上需要怎样的 “恢复” 工作，当时的人们并不清楚。

运行时异常（runtime exception）也包含进了 Java 中。由于空指针、数据错误和非法状态/访问都可能在代码中的任何地方发生，因此将它们作为运行时异常的子类型。运行时异常可以在任何地方抛出，而无需声明，并且更加方便。

《Think in java》中对 Java 异常地位的评价：

> 在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把 “概述在正常执行过程中做什么事” 的代码和 “出了问题怎么办” 的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。

### 合理的处理异常

在 IDEA 中运行程序，如果出错了，可以在控制台看到异常信息、堆栈信息，并以此为依据去解决问题。但是，服务通常是部署在服务器（Linux）上的，如果报错了，怎么知道异常信息是什么呢？，这就是日志。当然，其实不只是 Java 工程，任何工程都不能离开日志记录。通常会这样使用日志：

- 把工程中的异常信息记录到日志中，就可以通过查询日志去定位问题
- 把业务流程信息记录到日志中，就可以知道程序的执行流是怎样的
- 通过日志查看、分析用户的操作，用于分析用户行为、审计等等功能

所以，打日志对于程序员来说，也是不可或缺的技能之一。