---
title: 目录结构和文件管理指令
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2018-01-02 22:33:35 +0800
categories: [计算机基础, 操作系统]
tags: [Linux]
math: true
mermaid: true
---

##  Shell

Shell 是一个命令行的用户界面，将输入的指令，传递给操作系统去执行。

早期程序员没有图形界面用，就用 Shell。并且图形界面制作成本较高，不能实现所有功能，因此今天的程序员依然在用 Shell。

平时还会经常看到一个词叫作 bash（Bourne Again Shell），是用 Shell 组成的程序。其中 Bourne 是一个人名，Steve Bourne 是 bash 的发明者。

所有指令，不是写死在操作系统中的，而是一个个程序。比如 rm 指令，可以用 which 指令查看它所在的目录，如下图所示：

![this is images](https://maxpixelton.github.io/images/assert/os/0601.png)

如上面代码，root 是我的用户名，localhost 是我这台机器的名字。

我输入了 `which rm`，然后获得了`/usr/bin/rm`的结果，**最终执行这条指令的是操作系统，连接我和操作系统的程序就是 Shell。**

Linux 对**文件目录操作的指令**就工作在 Shell 上。

## Linux 对文件目录的抽象

Linux 对文件进行了一个树状的抽象。

==/==：代表根目录，每一节目录也用 ==/== 分开，所以在上面代码所展示的`/usr/bin/rm`中：

- 第一级目录是：==/== 根目录；
- 第二级目录是：usr 目录；
- 第三级目录是：bin目录；
- 最后的 rm 是一个文件。

### 路径（path）

像 `/usr/bin/rm` 称为**可执行文件 rm 的路径。**

**路径就是一个文件在文件系统中的地址。如果文件系统是树形结构，那么通常一个文件只有一个地址（路径）。**

**目标文件的绝对路径（Absolute path），也叫作完全路径（full path），是从 ==/== 开始，接下来每一层都是一级子目录，直到定位到目标文件为止。**

显然，`/usr/bin/rm`就是一个绝对路径。

### 工作目录

Shell 还抽象出了工作目录。

当打开 Shell 的时候，Shell 就会安排一个工作目录。因此也就产生了==**相对路径。**==

相对路径（Relative path）是**以工作目录为基点的路径**。比如：

- 当用户在 /usr 目录下的时候，rm 文件的相对路径就是 bin/rm；
- 如果用户在 /usr/bin 目录下的时候，rm 文件的路径就是./rm或者rm，这里用.代表当前目录；
- 如果用户在/usr/bin/somedir下，那么 rm 的相对路径就是 ../rm，这里用 .. 代表上一级目录。

使用 cd（change directory）指令切换工作目录，既可以用绝对路径，也可以用相对路径。 

不过，有几个需要注意的地方：

- 输入`cd`，不带任何参数会切换到用户的家目录，Linux 中通常是 /home/{用户名}。以我自己为例，我的家目录是/home/ramroll；
- 输入`cd` .什么都不会发生，因为 . 代表当前目录；
- 输入`cd..`会回退一级目录，因为..代表上级目录。

利用上面的内容，可以方便的构造相对路径了。

Linux 提供了一个指令 pwd（Print Working Directory）查看工作目录。下面输入 pwd 的结果：

![this is images](https://maxpixelton.github.io/images/assert/os/0602.png)

### 几种常见的文件类型

**Linux 下的目录也是一种文件，文件也不只有目录和可执行文件两种。**

常见的文件类型有以下 7 种：

- 普通文件，没有任何符号结尾，比如一个文本文件；
- 目录文件，以 / 结尾，目录是一个特殊的文件，用来存储文件清单，比如 /也是一个文件 ；
- 可执行文件，以 * 结尾； 
- 管道文件，以 | 结尾；
- Socket 文件，以 = 结尾；
- 软链接文件，以 @ 结尾，相当于指向另一个文件所在路径的符号；
- 硬链接文件，相当于指向另一个文件的指针。

使用命令`ls -F`就可以看到当前目录下的文件和它的类型，如下：

* 结尾的是可执行文件；
* = 结尾的是 Socket 文件；
* @ 结尾的是软链接；
* | 结尾的管道文件；
* 没有符号结尾的是普通文件；
* / 结尾的是目录。

![this is images](https://maxpixelton.github.io/images/assert/os/0603.png)

### 设备文件

Socket 是网络插座，是客户端和服务器之间同步数据的接口。

其实，Linux 不只把 Socket 抽象成了文件，设备基本也都被抽象成了文件。

因为设备需要不断和操作系统交换数据。而交换方式只有两种——读和写。所以设备是可以抽象成文件的，因为文件也支持这两种操作。

Linux 把所有的设备都抽象成了文件，比如说打印机、USB、显卡等。这让整体的系统设计变得高度统一。



## 文件的增删改查

### 增加

- 新建文件

  创建一个普通文件的方法有很多，最常见的有 `touch` 指令，如下：

  ```bash
  [root@localhost maya]# ls -al
  total 4
  drwxr-xr-x.  2 root root    6 Jun 28 10:49 .
  dr-xr-xr-x. 19 root root 4096 Jun 28 10:49 ..
  [root@localhost maya]# touch a.txt
  [root@localhost maya]# ls -al
  total 4
  drwxr-xr-x.  2 root root   19 Jun 28 10:50 .
  dr-xr-xr-x. 19 root root 4096 Jun 28 10:49 ..
  -rw-r--r--.  1 root root    0 Jun 28 10:50 a.txt
  [root@localhost maya]# 
  ```

  touch 指令本来是用来更改文件的时间戳的，如果文件不存在 touch 也会帮助创建一个空文件。

- 新建目录

  需要增加一个目录，就需要用到mkdir指令（ make directory），比如创建一个 hello 目录，如下：

  ```bash
  [root@localhost maya]# mkdir hello
  [root@localhost maya]# ls -al
  total 4
  drwxr-xr-x.  3 root root   32 Jun 28 10:51 .
  dr-xr-xr-x. 19 root root 4096 Jun 28 10:49 ..
  -rw-r--r--.  1 root root    0 Jun 28 10:50 a.txt
  drwxr-xr-x.  2 root root    6 Jun 28 10:51 hello
  [root@localhost maya]# 
  ```

  

> ps: 如果拿到一个指令不知道该怎么用，比如 touch，可以用 man touch 去获得帮助。
>
> man 意思是 manual，是说明书的意思，这里指的是系统的手册。
>
> 如果不知道 man 是什么，也可以使用 man man。



### 查看

使用 `ls 指令`看到这个文件，ls是 list 的缩写。下面是指令 'ls' 的执行结果。

如果想看更完善的信息，使用`ls -l`。-l 是 ls 指令的可选参数。

### 删除

删除使用命令 rm，rm 是 remove 的缩写。

删除文件，比如 a.txt ，用`rm a.txt`；

删除目录，比如 hello 目录，用`rm -r hello`。之所以多出一个 -r（recursive，递归），是因为目录是一个递归结构，所以需要用递归删除。

### 修改

修改一个文件，使用 nano 或者 vi/vim 编辑器。

类似的工具有很多，但是 nano 和vi 是 linux 自带的（vim 需要安装）。



## 查阅文件内容

Linux 下查阅文件内容，可以根据不同场景选择不同的指令。

### cat

当文件较小时，比如一个配置文件，想要快速浏览这个文件，可以用 cat 指令。cat指令将文件连接到**标准输出流**并打印到屏幕上。

> 标准输出流（Standard Output）也是一种文件，进程可以将要输出的内容写入标准输出流文件，这样就可以在屏幕中打印。

如果用 cat 查看大文件，比如一个线上的日志文件，动辄有几个 G，控制台打印出所有的内容就要非常久，而且刷屏显示看不到东西。如果在线上进行查看大文件的操作，会带来不必要的麻烦：

- 首先，由于需要把文件拷贝到输入输出流，需要花费很长时间，这个过程会占用机器资源；
- 其次，本身文件会读取到内存中，此时内存被大量占用，很危险，可能导致其他应用内存不足。因此需要一些不用加载整个文件，就能查看文件内容的指令。

### more

这个命令可以读取文件，但不需要读取整个文件到内存中。

本身 more 的定位是一个阅读过滤器，比如在 more 里除了可以向下翻页，还可以输入一段文本进行搜索。

比如：

- more 查看一个 nginx 日志后；
- 先输入一个 /，然后输入192.168 看到的结果；
- more 可以帮助找到 192.168 所在的位置，并且定位到了这个位置；
- 整个过程 more 指令只读取需要的部分到内存中。

### less

less 是一个和 more 功能差不多的工具。

打开 man 能够看到 less 的介绍上写着自己是 more 的反义词（opposite of more）。

由此看出 linux 生态是一个很自由的生态，不仅可以在这里创造工具也可以按照自己的喜好写文档。

less 支持向上翻页，这个功能 more 是做不到的。所以现在 less 用得更多一些。

### head/tail

head和tail是一组，用来读取一个文件的头部 N 行或者尾部 N 行。

比如一个线上的大日志文件，当线上出了 bug，服务暂停的时候，可以用 `tail -n 1000`去查看最后的 1000 行日志文件，寻找导致服务异常的原因。

另一个比较重要的用法是，如果想看实时的 nginx 日志，可以使用 `tail -f 文件名`，这样会看到用户的请求不断进来。查一下 man，发现 ==-f== 是 ==follow==的意思，就是**文件追加的内容会跟随输出到标准输出流。**

### grep

有时候需要查看一个指定 ip 的 nginx 日志，或者查看一段时间内的 nginx 日志。如果不想用 less 或 more 进入文件中去查看，就可以用 grep 命令。

Linux 的文件命名风格都很短，所以也影响了很多人，比如之前我看到过一个大牛的程序，变量名从来不超过 5 个字母，而且都有意义。

grep 这个词，分成三段来看，是 g|re|p：

- g 就是 global，全局；
- re 就是 regular expression，正则表达式；
- p 就是 pattern，模式。

因此这个指令的作用是：**通过正则表达式全局搜索一个文件找到匹配的模式。**

我觉得这种命名真的很牛，软件命名也是一个世纪难题，grep 这个名字不但发音不错，而且很有含义，又避免了名字过长，方便记忆。

两个 grep 的用法：

- 查找 ip 地址

  通过 grep 命令定位某个 ip 地址的用户都做了什么事情，如下所示：

  ```bash
  grep 80.82.207.86 ./nginx_logs.txt
  ```

  

- 查找时间段的日志

  通过 grep 命令查找某个时间段内用户都做了什么事情

  ```bash
  grep 19/May/2019:10:05 ./nginx_logs.txt
  ```

## 查找文件 find

之前使用过一个which指令，这个指令可以查询一个指令文件所在的位置，比如 `which grep`，会看到grep指令被安装的位置是/usr/bin。这还不够，需要一个更加通用的指令查找文件，也就是 find 指令。

### find

find 指令帮助我们在文件系统中查找文件。 

比如想要查找所有.txt 扩展名的文件，可以使用`find / -iname "*.txt"`，-iname 这个参数是用来匹配查找的，i 字母代表忽略大小写，这里也可以用-name替代。输入这条指令，你会看到不断查找文件，如下图所示：

## 总结

- pwd 指令，查看工作目录。

- cd指令切换工作目录。

- which指令查找一个执行文件所在的路径。

- ls 显示文件信息。

- rm 删除文件。

- touch 修改一个文件的时间戳，如果文件不存在会触发创建文件。

- vi 和 nano 可以用来编辑文件。

- cat 查看完成的文件，适合小型文件；
- more & less，查看一个文件但是只读取用户看到的内容到内存，因此消耗资源较少，适合在服务器上看日志。

- head & tail，可以用来看文件的头和尾。

- grep 指令搜索文件内容。

- find 指令,全局查找文件；
- man 指令，它是所有指令的手册，一个指令通常有非常多的参数，可以用 man 指令去仔细研究。

**rm / -rf 的作用是：**

- / 是文件系统根目录；
- rm是删除指令；
- -r 是 recursive（递归）；
- -f 是 force（强制），遇到只读文件也不提示，直接删除。

所以`rm -rf /` 就是删除整个文件系统上的所有文件，而且不用给用户提示。

警告：此命令是危险命令！禁用！禁用！禁用！


搜索文件系统中所有以包含 std 字符串且以 .h 扩展名结尾的文件：`sudo find / -name "*.h" | grep std` 或 `sudo find / -name "*std*.h"`
