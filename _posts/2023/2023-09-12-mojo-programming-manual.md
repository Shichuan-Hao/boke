---
title: Mojo é¡¹ç›®æ‰‹å†Œ
date: 2023-09-06 14:31:57 +0800
categories: [æ–‡ç« ]
tags: [Mojo] 
---


## MojoğŸ”¥ programming manual Mojo ğŸ”¥ é¡¹ç›®æ‰‹å†Œ
Mojo æ˜¯ä¸€ç§ä¸ Python ä¸€æ ·æ˜“äºä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†å…·æœ‰ C++ å’Œ Rust çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼ŒMojo è¿˜æä¾›äº†åˆ©ç”¨æ•´ä¸ª Python åº“ç”Ÿæ€ç³»ç»Ÿçš„èƒ½åŠ›ã€‚
Mojo is a programming language that is as easy to use as Python but with the performance of C++ and Rust. Furthermore, Mojo provides the ability to leverage the entire Python library ecosystem.

Mojo é€šè¿‡åˆ©ç”¨å…·æœ‰é›†æˆç¼“å­˜ã€å¤šçº¿ç¨‹å’Œäº‘åˆ†å‘æŠ€æœ¯çš„ä¸‹ä¸€ä»£ç¼–è¯‘å™¨æŠ€æœ¯æ¥å®ç°è¿™ä¸€å£®ä¸¾ã€‚æ­¤å¤–ï¼ŒMojo çš„è‡ªåŠ¨è°ƒæ•´å’Œç¼–è¯‘æ—¶å…ƒç¼–ç¨‹åŠŸèƒ½å…è®¸æ‚¨ç¼–å†™å¯ç§»æ¤åˆ°æœ€å¥‡ç‰¹ç¡¬ä»¶çš„ä»£ç ã€‚
Mojo achieves this feat by utilizing next-generation compiler technologies with integrated caching, multithreading, and cloud distribution technologies. Furthermore, Mojoâ€™s autotuning and compile-time metaprogramming features allow you to write code that is portable to even the most exotic hardware.

 
æ›´é‡è¦çš„æ˜¯ï¼Œ**Mojo å…è®¸æ‚¨åˆ©ç”¨æ•´ä¸ª Python ç”Ÿæ€ç³»ç»Ÿ**ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ç»§ç»­ä½¿ç”¨æ‚¨ç†Ÿæ‚‰çš„å·¥å…·ã€‚ Mojo æ—¨åœ¨é€šè¿‡ä¿ç•™ Python çš„åŠ¨æ€åŠŸèƒ½åŒæ—¶æ·»åŠ æ–°çš„ç³»ç»Ÿç¼–ç¨‹åŸè¯­ï¼ˆprimitivesï¼‰ï¼Œéšç€æ—¶é—´çš„æ¨ç§»æˆä¸º Python çš„**è¶…é›†**ã€‚è¿™äº›æ–°çš„ç³»ç»Ÿç¼–ç¨‹åŸè¯­å°†å…è®¸ Mojo å¼€å‘äººå‘˜æ„å»ºç›®å‰éœ€è¦ Cã€C++ã€Rustã€CUDA å’Œå…¶ä»–åŠ é€Ÿå™¨ç³»ç»Ÿçš„é«˜æ€§èƒ½åº“ã€‚é€šè¿‡å°†æœ€å¥½çš„åŠ¨æ€è¯­è¨€å’Œç³»ç»Ÿè¯­è¨€ç»“åˆåœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬å¸Œæœ›æä¾›ä¸€ä¸ªç»Ÿä¸€çš„ç¼–ç¨‹æ¨¡å‹ï¼Œè¯¥æ¨¡å‹å¯ä»¥è·¨æŠ½è±¡çº§åˆ«å·¥ä½œï¼Œå¯¹æ–°æ‰‹ç¨‹åºå‘˜å‹å¥½ï¼Œå¹¶ä¸”å¯ä»¥æ‰©å±•åˆ°ä»åŠ é€Ÿå™¨åˆ°åº”ç”¨ç¨‹åºç¼–ç¨‹å’Œè„šæœ¬ç¼–å†™çš„è®¸å¤šç”¨ä¾‹ã€‚
More importantly, **Mojo allows you to leverage the entire Python ecosystem** so you can continue to use tools you are familiar with. Mojo is designed to become a **superset** of Python over time by preserving Pythonâ€™s dynamic features while adding new primitives for [systems programming](https://en.wikipedia.org/wiki/Systems_programming). These new system programming primitives will allow Mojo developers to build high-performance libraries that currently require C, C++, Rust, CUDA, and other accelerator systems. By bringing together the best of dynamic languages and systems languages, we hope to provide a **unified** programming model that works across levels of abstraction, is friendly for novice programmers, and scales across many use cases from accelerators through to application programming and scripting.

æœ¬æ–‡æ¡£æ˜¯ Mojo ç¼–ç¨‹è¯­è¨€çš„ä»‹ç»ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„è¯­è¨€æŒ‡å—ã€‚å®ƒå‡å®šæ‚¨äº†è§£ Python å’Œç³»ç»Ÿç¼–ç¨‹æ¦‚å¿µã€‚ç›®å‰ï¼ŒMojo ä»åœ¨å¼€å‘ä¸­ï¼Œå…¶æ–‡æ¡£é¢å‘å…·æœ‰ç³»ç»Ÿç¼–ç¨‹ç»éªŒçš„å¼€å‘äººå‘˜ã€‚éšç€è¯¥è¯­è¨€çš„å‘å±•å’Œå˜å¾—æ›´åŠ å¹¿æ³›ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå¯¹æ¯ä¸ªäººï¼ˆåŒ…æ‹¬åˆå­¦è€…ç¨‹åºå‘˜ï¼‰éƒ½å‹å¥½ä¸”æ˜“äºä½¿ç”¨ã€‚åªæ˜¯ä»Šå¤©ä¸å­˜åœ¨äº†ã€‚
This document is an introduction to the Mojo programming language, not a complete language guide. It assumes knowledge of Python and systems programming concepts. At the moment, Mojo is still a work in progress and the documentation is targeted to developers with systems programming experience. As the language grows and becomes more broadly available, we intend for it to be friendly and accessible to everyone, including beginner programmers. Itâ€™s just not there today.
### Using the Mojo compiler  ä½¿ç”¨ Mojo ç¼–è¯‘å™¨
æ‚¨å¯ä»¥ä»ç»ˆç«¯è¿è¡Œ Mojo ç¨‹åºï¼Œå°±åƒä½¿ç”¨ Python ä¸€æ ·ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªåä¸º `hello.mojo`ï¼ˆæˆ– `hello.ğŸ”¥` - æ˜¯çš„ï¼Œæ–‡ä»¶æ‰©å±•åå¯ä»¥æ˜¯è¡¨æƒ…ç¬¦å·ï¼ï¼‰çš„æ–‡ä»¶ï¼Œåªéœ€è¾“å…¥ `mojo hello.mojo`ï¼š
You can run a Mojo program from a terminal just like you can with Python. So if you have a file named `hello.mojo` (or `hello.ğŸ”¥`â€”yes, the file extension can be an emoji!), just type `mojo hello.mojo`:
```bash
$ cat hello.ğŸ”¥
def main():
	print("hello world")
	for x in range(9, 0, -3):
		print(x)

$ mojo hello.ğŸ”¥
hello world
9
6
3
$
```
åŒæ ·ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `.ğŸ”¥` æˆ– `.mojo` åç¼€ã€‚
Again, you can use either the `.ğŸ”¥` or `.mojo` suffix.
### Basic systems programming extensions  åŸºæœ¬ç³»ç»Ÿç¼–ç¨‹æ‰©å±•
è€ƒè™‘åˆ°æˆ‘ä»¬çš„å…¼å®¹æ€§ç›®æ ‡ä»¥åŠ Python åœ¨é«˜çº§åº”ç”¨ç¨‹åºå’ŒåŠ¨æ€ API æ–¹é¢çš„ä¼˜åŠ¿ï¼Œæˆ‘ä»¬ä¸å¿…èŠ±å¤ªå¤šæ—¶é—´æ¥è§£é‡Šè¯¥è¯­è¨€çš„è¿™äº›éƒ¨åˆ†æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å¦ä¸€æ–¹é¢ï¼ŒPython å¯¹ç³»ç»Ÿç¼–ç¨‹çš„æ”¯æŒä¸»è¦å§”æ‰˜ç»™ Cï¼Œæˆ‘ä»¬å¸Œæœ›æä¾›ä¸€ä¸ªåœ¨è¿™ä¸ªä¸–ç•Œä¸Šå¾ˆæ£’çš„å•ä¸€ç³»ç»Ÿã€‚å› æ­¤ï¼Œæœ¬èŠ‚è¯¦ç»†ä»‹ç»äº†æ¯ä¸ªä¸»è¦ç»„ä»¶å’ŒåŠŸèƒ½ï¼Œå¹¶é€šè¿‡ç¤ºä¾‹æè¿°äº†å¦‚ä½•ä½¿ç”¨å®ƒä»¬ã€‚
Given our goal of compatibility and Pythonâ€™s strength with high-level applications and dynamic APIs, we donâ€™t have to spend much time explaining how those portions of the language work. On the other hand, Pythonâ€™s support for systems programming is mainly delegated to C, and we want to provide a single system that is great in that world. As such, this section breaks down each major component and feature and describes how to use them with examples.
#### `let` and `var` declarations `let` å’Œ `var` å£°æ˜
åœ¨ Mojo ä¸­çš„ def å†…éƒ¨ï¼Œæ‚¨å¯ä»¥ä¸ºåç§°åˆ†é…ä¸€ä¸ªå€¼ï¼Œå®ƒä¼šéšå¼åˆ›å»ºä¸€ä¸ªå‡½æ•°ä½œç”¨åŸŸå˜é‡ï¼Œå°±åƒåœ¨ Python ä¸­ä¸€æ ·ã€‚è¿™æä¾›äº†ä¸€ç§éå¸¸åŠ¨æ€ä¸”ç®€å•çš„ä»£ç ç¼–å†™æ–¹å¼ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªæŒ‘æˆ˜ï¼ŒåŸå› æœ‰äºŒï¼š

1.  ç³»ç»Ÿç¨‹åºå‘˜é€šå¸¸å¸Œæœ›å£°æ˜ä¸€ä¸ªå€¼æ˜¯ä¸å¯å˜çš„ï¼Œä»¥ä¿è¯ç±»å‹å®‰å…¨å’Œæ€§èƒ½ã€‚
2.  å¦‚æœä»–ä»¬åœ¨èµ‹å€¼ä¸­è¾“é”™äº†å˜é‡åï¼Œä»–ä»¬å¯èƒ½å¸Œæœ›å¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚

Inside a `def` in Mojo, you may assign a value to a name and it implicitly creates a function scope variable just like in Python. This provides a very dynamic and low-ceremony way to write code, but it is a challenge for two reasons:

1. Systems programmers often want to declare that a value is immutable for type-safety and performance.
2. They may want to get an error if they mistype a variable name in an assignment.

 
ä¸ºäº†æ”¯æŒè¿™ä¸€ç‚¹ï¼ŒMojo æä¾›äº†ä½œç”¨åŸŸè¿è¡Œæ—¶å€¼å£°æ˜ï¼š`**let**`** æ˜¯ä¸å¯å˜çš„**ï¼Œ`**var**`** æ˜¯å¯å˜çš„**ã€‚è¿™äº›å€¼ä½¿ç”¨è¯æ³•ä½œç”¨åŸŸï¼ˆuse lexical scopingï¼‰å¹¶æ”¯æŒåç§°é®è”½ï¼š
To support this, Mojo provides scoped runtime value declarations: `**let**`** is immutable, and **`**var**`** is mutable.** These values use lexical scoping and support name shadowing:
```python
def your_function(a, b):
    let c = a
    # Unconment to see an error
    # c = b # error: c is immutable

    if c != b:
        let d = b
        print(d)

your_function(2, 3)

# results
# 3
```

`let` å’Œ `var` å£°æ˜æ”¯æŒç±»å‹è¯´æ˜ç¬¦å’Œæ¨¡å¼ä»¥åŠåæœŸåˆå§‹åŒ–ï¼š
`let` and `var` declarations support type specifiers as well as patterns, and late initialization:
```python
def your_function():
    let x: Int = 42
    let y: Float64 = 17.0

    let z: Float32
    if x != 0:
        z = 1.0
    else:
        z = foo()
    print(z)

def foo() -> Float32:
    return 3.14

your_function()

# results
# 1.0
```
 
è¯·æ³¨æ„ï¼Œlet å’Œ var åœ¨ def å‡½æ•°ä¸­æ˜¯å®Œå…¨å¯é€‰çš„ï¼ˆæ‚¨å¯ä»¥ä½¿ç”¨éšå¼å£°æ˜çš„å€¼ï¼Œå°±åƒ Python ä¸€æ ·ï¼‰ï¼Œä½†å®ƒä»¬å¯¹äº fn å‡½æ•°ä¸­çš„æ‰€æœ‰å˜é‡éƒ½æ˜¯å¿…éœ€çš„ã€‚
Note that `let` and `var` are completely optional when in a `def` function (you can instead use implicitly declared values, just like Python), but theyâ€™re required for all variables in an `fn` function.

å¦è¯·æ³¨æ„ï¼Œåœ¨ REPL ç¯å¢ƒï¼ˆä¾‹å¦‚æœ¬ç¬”è®°æœ¬ï¼‰ä¸­ä½¿ç”¨ Mojo æ—¶ï¼Œé¡¶çº§å˜é‡ï¼ˆä½äºå‡½æ•°æˆ–ç»“æ„ä¹‹å¤–çš„å˜é‡ï¼‰ä¼šè¢«è§†ä¸º `def` ä¸­çš„å˜é‡ï¼Œå› æ­¤å®ƒä»¬å…è®¸éšå¼å€¼ç±»å‹å£°æ˜ï¼ˆå®ƒä»¬ä¸å…è®¸éœ€è¦ `var` æˆ– `let` å£°æ˜ï¼Œä¹Ÿä¸éœ€è¦ç±»å‹å£°æ˜ï¼‰ã€‚è¿™ä¸ Python REPL è¡Œä¸ºç›¸åŒ¹é…ã€‚
Also beware that when using Mojo in a REPL environment (such as this notebook), top-level variables (variables that live outside a function or struct) are treated like variables in a `def`, so they allow implicit value type declarations (they do not require `var` or `let` declarations, nor type declarations). This matches the Python REPL behavior.
#### `struct`types ç»“æ„ç±»å‹
Mojo åŸºäº MLIR å’Œ LLVMï¼Œæä¾›äº†ç”¨äºå¤šç§ç¼–ç¨‹è¯­è¨€çš„å°–ç«¯ç¼–è¯‘å™¨å’Œä»£ç ç”Ÿæˆç³»ç»Ÿã€‚è¿™è®©æˆ‘ä»¬å¯ä»¥æ›´å¥½åœ°æ§åˆ¶æ•°æ®ç»„ç»‡ã€ç›´æ¥è®¿é—®æ•°æ®å­—æ®µä»¥åŠå…¶ä»–æé«˜æ€§èƒ½çš„æ–¹æ³•ã€‚ç°ä»£ç³»ç»Ÿç¼–ç¨‹è¯­è¨€çš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯èƒ½å¤Ÿåœ¨è¿™äº›å¤æ‚çš„ä½çº§æ“ä½œä¹‹ä¸Šæ„å»ºé«˜çº§ä¸”å®‰å…¨çš„æŠ½è±¡ï¼Œè€Œä¸ä¼šé€ æˆä»»ä½•æ€§èƒ½æŸå¤±ã€‚åœ¨ Mojo ä¸­ï¼Œè¿™æ˜¯ç”±ç»“æ„ç±»å‹æä¾›çš„ã€‚
Mojo is based on MLIR and LLVM, which offer a cutting-edge compiler and code generation system used in many programming languages. This lets us have better control over data organization, direct access to data fields, and other ways to improve performance. An important feature of modern systems programming languages is the ability to build high-level and safe abstractions on top of these complex, low-level operations without any performance loss. In Mojo, this is provided by the struct type.

Mojo ä¸­çš„ç»“æ„ç±»ä¼¼äº Python ç±»ï¼šå®ƒä»¬éƒ½æ”¯æŒæ–¹æ³•ã€å­—æ®µã€è¿ç®—ç¬¦é‡è½½ã€å…ƒç¼–ç¨‹è£…é¥°å™¨ç­‰ã€‚å®ƒä»¬çš„åŒºåˆ«å¦‚ä¸‹ï¼š

-  Python ç±»æ˜¯åŠ¨æ€çš„ï¼šå®ƒä»¬å…è®¸åŠ¨æ€è°ƒåº¦ã€çŒ´å­ä¿®è¡¥ï¼ˆæˆ–â€œswizzlingâ€ï¼‰ä»¥åŠåœ¨è¿è¡Œæ—¶åŠ¨æ€ç»‘å®šå®ä¾‹å±æ€§ã€‚
-  Mojo ç»“æ„æ˜¯é™æ€çš„ï¼šå®ƒä»¬åœ¨ç¼–è¯‘æ—¶ç»‘å®šï¼ˆä¸èƒ½åœ¨è¿è¡Œæ—¶æ·»åŠ æ–¹æ³•ï¼‰ã€‚ç»“æ„å…è®¸æ‚¨ä»¥çµæ´»æ€§æ¢å–æ€§èƒ½ï¼ŒåŒæ—¶å®‰å…¨ä¸”æ˜“äºä½¿ç”¨ã€‚

A struct in Mojo is similar to a Python class: they both support methods, fields, operator overloading, decorators for metaprogramming, etc. Their differences are as follows:

- Python classes are dynamic: they allow for dynamic dispatch, monkey-patching (or "swizzling"), and dynamically binding instance properties at runtime.
- Mojo structs are static: they are bound at compile-time (you cannot add methods at runtime). Structs allow you to trade flexibility for performance while being safe and easy to use.

 
è¿™æ˜¯ç»“æ„ä½“çš„ç®€å•å®šä¹‰ï¼š
Here's a simple definition of a struct:
```python
struct MyPair:
    var first: Int
    var second: Int

    # We use 'fn' instead of 'def' here
	# we'll explain that soon
    fn __init__(inout self, first: Int, second: Int):
        self.first = first
        self.second = second

    fn __lt__(self, rhs: MyPair) -> Bool:
        return self.first < rhs.first or
              (self.first == rhs.first and
               self.second < rhs.second)
```
ä»è¯­æ³•ä¸Šè®²ï¼Œä¸ Python `ç±»`ç›¸æ¯”ï¼Œæœ€å¤§çš„åŒºåˆ«æ˜¯`ç»“æ„`ä¸­çš„æ‰€æœ‰å®ä¾‹å±æ€§éƒ½å¿…é¡»ä½¿ç”¨ `var` æˆ– `let` å£°æ˜æ˜¾å¼å£°æ˜ã€‚
Syntactically, the biggest difference compared to a Python class is that all instance properties in a struct **must** be explicitly declared with a `var` or `let` declaration.

 
åœ¨ Mojo ä¸­ï¼Œâ€œstructâ€çš„ç»“æ„å’Œå†…å®¹æ˜¯é¢„å…ˆè®¾ç½®çš„ï¼Œå¹¶ä¸”åœ¨ç¨‹åºè¿è¡Œæ—¶æ— æ³•æ›´æ”¹ã€‚ä¸ Python ä¸åŒï¼Œåœ¨ Python ä¸­æ‚¨å¯ä»¥åŠ¨æ€æ·»åŠ ã€åˆ é™¤æˆ–æ›´æ”¹å¯¹è±¡çš„å±æ€§ï¼Œè€Œ Mojo ä¸å…è®¸å¯¹ç»“æ„è¿›è¡Œè¿™ç§æ“ä½œã€‚è¿™æ„å‘³ç€æ‚¨ä¸èƒ½åœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ä½¿ç”¨ `del` åˆ é™¤æ–¹æ³•æˆ–æ›´æ”¹å…¶å€¼ã€‚
In Mojo, the structure and contents of a "struct" are set in advance and can't be changed while the program is running. Unlike in Python, where you can add, remove, or change attributes of an object on the fly, Mojo doesn't allow that for structs. This means you can't use `del` to remove a method or change its value in the middle of running the program.


#### Strong type checking
#### Overloaded functions and methods
#### fn definitions
#### The __copyinit__ and __moveinit__ special methods

### Argument passing control and memory ownership
#### Why argument conventions are important
#### Immutable arguments (borrowed)
#### Mutable arguments (inout)
#### Transfer arguments (owned and ^)
#### Comparing def and fn argument passing

### Python integration
#### Importing Python modules
#### Mojo types in Python

### Parameterization: compile-time metaprogramming
#### Defining parameterized types and functions
#### Overloading on parameters
#### Using parameterized types and functions
#### Parameter expressions are just Mojo code
#### Powerful compile-time programming
#### Mojo types are just parameter expressions
#### alias: named parameter expressions
#### Autotuning / Adaptive compilation
### "Value Lifecycle": Birth, life and death of a value
#### Types that cannot be instantiated
#### Non-movable and non-copyable types
#### Unique "move-only" types
#### Types that support a â€œstealing move
#### Trivial types
#### `@value` decorator

### Behavior of destructors
#### Field-sensitive lifetime management
#### Field lifetimes in __init__
#### Field lifetimes of owned arguments in __moveinit__ and __del__
#### Defining the __del__ destructor
### Lifetimes
### Type traits ç±»å‹ç‰¹å¾
è¿™æ˜¯ä¸€ä¸ªéå¸¸ç±»ä¼¼äº Rust ç‰¹å¾æˆ– Swift åè®®æˆ– Haskell ç±»å‹ç±»çš„åŠŸèƒ½ã€‚è¯·æ³¨æ„ï¼Œè¿™å°šæœªå®æ–½ã€‚
This is a feature very much like Rust traits or Swift protocols or Haskell type classes. Note, this is not implemented yet.
### Advanced/Obscure Mojo features é«˜çº§/æ™¦æ¶©çš„ Mojo åŠŸèƒ½
#### `@register_passable` struct decorator
#### `@always_inline` decorator
#### `@parameter` decorator
#### Magic operators
#### Direct access to MLIR
#### 







å‘çš„
### 
