---
title: 线性表结构下的增删查
author:
  name: superhsc
  link: https://github.com/maxpixelton
date: 2022-01-04 20:33:35 +0800
categories: [计算机基础, 数据结构和算法]
tags: [线性表]
math: true
mermaid: true
---

## 什么是数据结构
数据结构，从名字上看是数据的结构，也就是数据的组织方式。

在数据结构适用的场合中，需要有一定量数据。如果数据都没有，也就不用讨论数据如何组织。当有了一定数量数据时，就需要考虑以什么方式对这些数据进行组织。

假设你是一所幼儿园的园长，现在正在组织一场运动会，所有的小朋友需要在操场上接受检阅。那么，如何组织小朋友有序站队并完成检阅 ？

几个可能的方式是：

- 让所有小朋友站成一横排；
- 或者让小朋友站成方阵；
- 又或者让所有小朋友手拉手，围成一个大圆圈等等。

很显然，这里有无数种可行的组织方式。具体选择哪个组织方式，取决于哪一种能更好地展示出小朋友们的风采。

类比一下，当计算机要处理大量数据时，同样需要考虑如何去组织这些数据，这就是数据结构。类似于小朋友站队方式有无数种情况，数据组织方式也是有无数种可能性。

![](https://maxpixelton.github.io/images/assert/structures/0401.gif)


然而，在实际开发中，经过工程师验证并且能有效解决问题的高效率数据结构就比较有限。事实上，只要把这些能真正解决问题的数据结构学会，就足以成为一名合格的软件工程师了。
## 什么是线性表
**线性表是 n 个数据元素的有限序列，最常用的是链式表达，通常也叫作线性链表或者链表。**

在链表中存储的数据元素叫作**结点**，**一个结点存储的就是一条数据记录**。

每个结点的结构包括两个部分：

1. 具体数据值；
2. 指针。指向下一个结点。

![](https://maxpixelton.github.io/images/assert/structures/0402.png)

在链表最前面，通常会有个**头指针**用来指向第一个结点。对于链表最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。链表结构，和小朋友手拉手站成一排的场景是非常相似的。

假设，需要处理的数据集是 10 个同学考试的得分。如果用链表进行存储，就会得到如下的数据：

![](https://maxpixelton.github.io/images/assert/structures/0403.png)

仔细观察上图，会发现这个链表只能通过上一个结点的指针找到下一个结点，反过来则是行不通的。因此，这样的链表也被称作**单向链表。**

有时候为了弥补单向链表的不足，可以对结点的结构进行改造：

- 对于一个单向链表，让最后一个元素的指针指向第一个元素，就得到了**循环链表**；

  ![](https://maxpixelton.github.io/images/assert/structures/0404.png)

- 或者把结点的结构进行改造，除了有指向下一个结点的指针以外，再增加一个指向上一个结点的指针。这样就得到了**双向链表**；

  ![](https://maxpixelton.github.io/images/assert/structures/0405.png)

- 还可以对双向链表和循环链表进行融合，就得到了**双向循环链表**，如下图所示：  

  ![](https://maxpixelton.github.io/images/assert/structures/0406.png)

这些种类的链表，都是**以单向链表为基础进行的变种**。**在某些场景下能提高线性表的效率**。
## 线性表对于数据的增删查处理
围绕数据的增删查操作，看看线性表的表现（主要是单向链表的增删查操作，其他类型的链表与此雷同）。

### 增加操作

如下链表，它存储了 10 个同学的考试成绩。现发现这样问题，在这个链表中，有一个同学的成绩忘了被存储进去。

假设要把成绩在红色的结点之后插入，该如何进行呢？

其实，链表在执行数据新增时非常容易，只需把待插入结点的指针指向原指针的目标，把原来指针指向待插入结点即可。

如下图所示：

![](https://maxpixelton.github.io/images/assert/structures/0407.png)

代码如下：

```java
s.next = p.next;
p.next = s;
```

### 删除操作 

还是这个存储了同学们考试成绩的链表，假设里面有个成绩样本是被误操作放进来，我们需要把这个样本删除。

链表的删除操作跟新增操作一样，都非常简单。如果待删除的结点为 b，那么只需要把指向 b 的指针 （p.next），指向 b 指针指向的结点（p.next.next）。如下图所示：  

![](https://maxpixelton.github.io/images/assert/structures/0408.png)

 代码如下：  

```java
p.next = p.next.next;
```

### 查找操作

查找操作有两种情况：

1. 按照位置序号来查找。

   和数组中的 index 是非常类似的。假设一个链表中，按照学号存储了 10 个同学的考试成绩。现在要查找出学号等于 5 的同学，他的考试成绩是多少，该怎么办呢？

   其实，链表的查找功能是比较弱的，对于这个查找问题，**唯一的办法就是一个一个地遍历去查找。**也就是，从头开始，先找到学号为 1 的同学，再经过他跳转到学号为 2 的同学。直到经过多次跳转，找到了学号为 5 的同学，才能取出这个同学的成绩。如下图所示：

   ![](https://maxpixelton.github.io/images/assert/structures/0409.gif)

2. 按照具体成绩查找。

   同样，假设在一个链表中，存储了 10 个同学的考试成绩。现在要查找出是否有人得分为 95 分。

   链表价值在于用指针按照顺序连接了数据结点，但对于每个结点数值则没有任何整合。当需要按照数值条件进行查找时，除按照先后顺序进行遍历外别无他法。

   因此，解决方案是，判断第一个结点的值是否等于 95：

   - 如果是，则返回有人得分为 95 分；

   - 如果不是，则需要通过指针去判断下一个结点的值是否等于 95。以此类推，直到把所有结点都访问完。

     ![](https://maxpixelton.github.io/images/assert/structures/0410.gif)

     ![](https://maxpixelton.github.io/images/assert/structures/0411.gif)

根据这里的分析不难发现：

- 链表在新增、删除数据都比较容易，可以在 $O(1)$ 的时间复杂度内完成；
- 但对于查找，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行遍历。这显然就是 $O(n)$ 的时间复杂度。

虽然链表在新增和删除数据上有优势，但仔细想想就会发现，这个优势并不实用。这主要是因为，**在新增数据时，通常会伴随一个查找的动作。**

例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：

1. 查找第五个结点；

2. 再新增一个数据结点。整体的复杂度就是 $O(n) + O(1)$。根据复杂度计算方法，这等同于 O(n) 的时间复杂度。

   ![](https://maxpixelton.github.io/images/assert/structures/0412.gif)

线性表真正的价值在于，**它对数据的存储方式是按照顺序的存储。如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，则链表会比较合适。如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。**

## 线性表案例
关于线性表，最高频的问题都会围绕数据顺序的处理。

**例 1，链表翻转。给定一个链表，输出翻转后的链表。例如，输入1 ->2 -> 3 -> 4 ->5，输出 5 -> 4 -> 3 -> 2 -> 1。**

先思考该问题难点在哪里，这里有两种情况：

1. 如果是数组的翻转，非常容易。原因是：数组是在连续空间进行存储，可以直接求解出数组长度，而后通过索引值查找元素，最后对相应数据进行交换操作完成翻转；

2. 但对于单向链表，它的指针结构造成了自身数据通路有去无回，一旦修改某个指针，后面数据就会造成失联状态。为了解决这个问题，需要构造三个指针 privious、current  和 next，对当前结点、以及它之前和之后结点进行缓存，再完成翻转动作。

   具体如下图所示：

   ![](https://maxpixelton.github.io/images/assert/structures/0413.gif)

   代码如下：

   ```java
   public class ReverseList {
   
        ListNode s1(ListNode head) {
            if (head == null) {
                return null;
            }
            ListNode curr = head;
            ListNode pre = null;
            while (curr != null) {
                // 断开链表，记录后续一个
                ListNode next = curr.next;
                // 当前的 next 指向前一个
                curr.next = pre;
                // 前一个更新为当前的
                pre = curr;
                // 当前更新为刚刚记录的后一个
                curr = next;
            }
            return pre;
        }
   
   }
   
   ```

   

**例 2，给定一个奇数个元素链表，查找出这个链表中间位置结点数值。**

这个问题也是利用了链表长度无法直接获取的不足做文章，解决办法如下：

- 暴力解法。先通过一次遍历去计算链表的长度，这样就知道链表中间位置是第几个；接着再通过一次遍历查找这个位置的数值；

- 快慢指针解法。该方法较为巧妙，其中快指针每次循环向后跳转两次，慢指针每次循环向后跳转一次。

  如下图所示：

  ![](https://maxpixelton.github.io/images/assert/structures/0414.gif)

  代码如下：
  
  ```java
  public class MiddleNode {
      
      ListNode MiddleNode(ListNode head) {
          if (head == null) {
              return null;
          }
          ListNode fast = head;
          ListNode slow = head;
          while (fast != null && fast.next != null) {
              fast = fast.next.next;
              slow = slow.next;
          }
          return slow;
      }
      
  }
  ```

 

**例 3，判断链表是否有环。如下图所示，这就是一个有环的链表。**  

![](https://maxpixelton.github.io/images/assert/structures/0416.png)

链表的快慢指针方法，在很多链表操作场景下都非常适用，对于这个问题也是一样。

假设链表有环，这个环里面就像跑步赛道的操场。经过多次循环之后，快指针和慢指针都会进入到这个赛道中，好比两个人在比赛，快指针每次走两格，慢指针每次走一格，相对而言，快指针每次循环会多走一步。这意味着：

- 如果链表存在环，快指针和慢指针一定会在环内相遇，即`fast == slow` 情况一定会发生。反之，最终完成循环，二者从未相遇。

根据这个性质就能对链表是否有环进行准确判断 。如下图所示：

![](https://maxpixelton.github.io/images/assert/structures/0415.gif)

代码如下：

```java
public class HasCycle {
    public boolean hasCycle(ListNode head) {
        // 先判断链表为空的情况
        if(head == null) {
            return false;
        }
        // 快慢双指针
        ListNode slow = head;
        ListNode fast = head;
        // 如果没环，快指针会先到链表尾
        while(fast != null && fast.next != null) {
            // 快指针移动两步
            slow = slow.next;
            // 慢指针移动一步
            fast = fast.next.next;
            // 相遇则有环
            if(slow == fast) {
                return true;
            }
        }
        // 到末尾则没有环
        return false;
    }
}
```



### 总结

- 线性链表结构每个结点，由数据的数值和指向下一个元素的指针构成；
- 根据结构组合方式的不同，链表分为：
  - 单向链表；
  - 双向链表；
  - 循环链表；
  - 双向循环链表等变形；
- 链表在增、删方面比较容易实现，可在 $O(1)$ 时间复杂度内完成；但对于查找，不管是按照位置查找还是按照数值条件查找，都需要对全部数据进行遍历；
- 线性表的价值在于：对数据的存储方式是按照顺序的存储。因此链表笔记适合数据元素个数不确定，且需要经常进行数据新增和删除时的场景；
- 链表的翻转、快慢指针的方法，是必须掌握。
