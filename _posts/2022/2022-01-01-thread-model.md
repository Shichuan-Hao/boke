---
title: Java 线程模型
author: Shaun
date: 2022-01-01 22:33:00 +0800
categories: [博客]
tags: [java thread]
math: true
mermaid: true
---

## 问题

1. 线程类型有哪些 ？

2. 线程模型有哪些 ？

3. 各语言使用的是哪种线程模型 ？

## 简介

在 Java 中，大家经常所说的**并发编程**、**多线程**、**共享资源**等概念都是与线程相关的，这里所说的线程实际上应该叫作**用户线程**，而对应到操作系统，还有另外一种线程叫做**内核线程**。

- **用户线程**位于内核之上，它的管理不需要内核支持。

- **内核线程**由操作系统来直接支持与管理。

几乎所有的现代操作系统，包括 Windows、Linux、Mac OS X 和 Solaris，都支持内核线程。

最终，**用户线程**和**内核线程**之间必然存在某种关系，常见的三种关系：

- **多对一模型**

- **一对一模型**

- **多对多模型**

### 多对一模型

![用户线程和内核线程的多对一模型](https://shichuan-hao.github.io/images/static/thread-m-1.jpg)

**多对一线程模型**，又称为**用户级线程模型**，<font color=red>即多个用户线程对应到同一个内核线程上，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。</font>

**优点：**

- **用户线程**的很多操作对内核来说都是透明的，不需要**用户态**和**内核态**的频繁切换，使线程的**创建**、**调度**、**同步**等非常快。

**缺点：**

- 由于**多个用户线程**对应到**同一个内核线程**，如果其中一个用户线程阻塞，那么其他用户线程也无法执行。

- **内核**不知道**用户态**有哪些线程，无法像内核线程一样实现较为完整的**调度**、**优先级**等。

***许多语言实现的协程库基本上都属于这种方式，比如 Python 的 `gevent`。***


### 一对一模型

![用户线程和内核线程的一对一模型](https://shichuan-hao.github.io/images/static/thread-1-1.jpg)

**一对一线程模型**，又称为**内核级线程模型**，<font color=red>即一个用户线程对应一个内核线程，内核负责每个线程的调度，可以调度到其他处理器上面。</font>

**优点：**

- 实现简单

**缺点：**

- 用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换。

- 内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。

***Java 使用的就是一对一线程模型，所有在 Java 中启动一个线程要谨慎 ！！！***

### 多对多模型

![用户线程和内核线程的多对多模型](https://shichuan-hao.github.io/images/static/thread-m-n.jpg)

**多对多模型**，又称为**两级线程模型**，<font color=red>它是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。</font>

在此模型下，**用户线程**与**内核线程**是**多对多（m:n，通常 m >= n）的映射模型。**

首先，区别于**多对一模型**，**多对多模型**中的一个进程可以与多个内核线程关联，于是进程内的多个用户线程可以绑定不同的内核线程，这点和一对一模型相似。

其实，又区别于**一对一模型**，它的进程里的所有用户线程并不与内核线程一一绑定，而是可以动态绑定内核线程，当某个内核线程因为其绑定的用户线程的阻塞操作被内核调度让出 CPU 时，其关联的进程中其余用户线程可以重新与其他内核线程绑定运行。

所以，**多对多模型**既不是多对一模型那种完全靠自己调度的也不是一对一模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协调工作），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现。

**优点：**

- 兼具多对一模型的轻量。

- 由于对应了多个内核线程，当一个用户线程阻塞时，其他用户线程仍然可以执行。

- 由于对应了多个内核线程，就可以实现较完成的调度、优先级等。

**缺点：**

- 用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换。

- 内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。

***Go 语言中的 goroutine 调度器就是采用的这种实现方案，在 Go 语言中一个进程可以启动成千上万个 goroutine，这也是其出道以来就自带 “高并发” 光环的重要原因。与 Java 中的 ForkJoinPool 非常类似。***

## 总结

1. 线程分为**用户线程**和**内核线程**。

2. 线程模型分为**一对一模型**、**多对多模型**、**多对一模型**。

3. 操作系统一般只实现到**一对一模型**。

4. Java 使用的是 **一对一线程模型**，所以它的一个线程对应于一个内核线程，调度完全交给操作系统来处理。

5. Go 语言使用的是 **多对多线程模型**，这正是其高并发的原因，它的线程模型与 Java 中的 ForkJoinPool 非常类似。

6. Python 的 `gevent` 使用的是**多对一线程模型**。

